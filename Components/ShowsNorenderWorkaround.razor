<h4>Shows render overhead</h4>

This section shows how the render overhead could be avoided with a <code>norender</code> on the binding. We have @Foo.N elements (just the first is displayed, but the others will still be consume time, if rendered) 

@foreach (var element in Elements)
{
    var first = Elements.First();
    @bind_to_without_render_on_value_changed((element, first))
}
<hr />
@code {
    private List<Foo> Elements = Enumerable.Range(0, Foo.N).Select(i => new Foo { Value = i }).ToList();
    private static object no_render = new object();
    private static RenderFragment<(Foo, Foo)> bind_to_without_render_on_value_changed = ((Foo element, Foo first) value) => (builder) =>
    {
        var element = value.element;
        var first = value.first;
        builder.OpenComponent<BindTo>(0);
        builder.AddAttribute(1, "Value", element.Value);
        // The following line is nearly identical to the normal code generated by @bind, except we don't use a reference to this as first parameter.
        // Instead, we use a pseudo-object. This avoids the NRE as opposed to passing null, and prevents rendering of this, as the EventCallback doesn't know about this.
        builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<int>(no_render, (v) => element.Value = v));
        builder.AddAttribute(3, "Show", element == first);
        builder.CloseComponent();
    };
}