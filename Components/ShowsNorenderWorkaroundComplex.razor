<h4>Shows render overhead avoidance (with complex component)</h4>

This section shows how the render overhead could be avoided with a <code>norender</code> on the binding. We have @N elements (just the first is displayed, but the others will still be consume time, if rendered) 

@foreach (var element in Elements)
{
    var first = Elements.First();
    @bind_to_without_render_on_value_changed((element, first))
}
<hr />
@code {
    [Parameter] public int N { get; set; }
    protected override void OnInitialized()
    {
        Elements = Enumerable.Range(0, N).Select(i => new Foo { Value = i }).ToList();
        base.OnInitialized();
    }
    protected override void OnParametersSet()
    {
        if (Elements == null || Elements.Count != N)
        {
            Elements = Enumerable.Range(0, N).Select(i => new Foo { Value = i }).ToList();
        }
        base.OnParametersSet();
    }
    private List<Foo> Elements;
    private static object no_render = new object();
    private static RenderFragment<(Foo, Foo)> bind_to_without_render_on_value_changed = ((Foo element, Foo first) value) => (builder) =>
    {
        var element = value.element;
        var first = value.first;
        builder.OpenComponent<BindToComplex>(0);
        builder.AddAttribute(1, "Value", element.Value);
        // The following line is nearly identical to the normal code generated by @bind, except we don't use a reference to this as first parameter.
        // Instead, we use a pseudo-object. This avoids the NRE as opposed to passing null, and prevents rendering of this, as the EventCallback doesn't know about this.
        builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<int>(no_render, (v) => element.Value = v));
        builder.AddAttribute(3, "Show", element == first);
        builder.CloseComponent();
    };
}